---
typora-root-url: ../../../../static
typora-copy-images-to: ../../../../static
---

# 设计

MySQL主要面向的是OLTP场景，所以数据记录采用行存（NSM - n-ary storage model）。

基于行进行存储有以下几个好处：

- 记录存放在一个页中，存储一条记录需要访问的页面较少
- 符合传统机械硬盘的访问方式
- 易于理解，数据的存取就像是对一张二维表进行访问

在整体上看，表中的数据是按照如下形式组织的：

![InnoDB record表中的行](/InnoDB_record表中的行.png)

那我们如何来理解记录呢？

首先，在关系数据库系统理论中，通常用元组（tuple）描述记录，用字段（field）描述列，每个元组由多个字段组成，每个表由多个元组组成。

行和元组在意义上是相等的。但是更愿意将行（row）理解为物理记录，将元组（tuple）理解为逻辑记录。物理记录为行实际存放在物理存储中的格式，其内容由二进制字符串组成，可读性差。逻辑记录则容易理解的多，每张表中的多个记录就像是一个数组。由于其只是“逻辑”上的含义，因此逻辑记录只是物理记录在内存中的表现形式，实际并不占用任何的物理存储空间。

关系如下图所示：

![InnoDB record 记录的展现](/InnoDB_record记录的展现.png)

物理记录和逻辑记录的差异如下：

|          | **物理记录**                         | **逻辑记录**           |
| -------- | ------------------------------------ | ---------------------- |
| 可读性   | 差                                   | 好                     |
| 存储位置 | 磁盘                                 | 内存                   |
| 亲和性   | 对存储友好（更紧凑）                 | 对查找友好（更易寻址） |
| 存储内容 | 除记录中的列数据外，还有一些额外信息 | 元组                   |

这两种记录之间本身可以互相转换。比如，在插入一条记录时，原来没有数据，首先需要根据插入的记录构造一个逻辑记录，然后再存放到磁盘上。对于读取，要从磁盘上seek出来相应的数据页，再将页中的物理记录转换成逻辑记录展现给用户。

除此之外，在MySQL server层也需要在binlog中记录数据的变化，也需要一种行格式。因此，在MySQL中，行格式一共有3种存储方式：

- Server层格式：与存储引擎无关，server层的binlog行格式（Row-Base Replication下的binlog格式）
- 逻辑记录格式：tuple，也称为索引元组格式（因为InnoDB是IOT）。在同一个表中，不同索引对应的元组是不同的
- 物理记录格式：record，也称为physical record

## 物理记录的设计

物理记录承载着数据的最终存储，因此，我们首先讨论物理记录。

磁盘上的物理记录需要面向计算机友好，更紧凑、强调IO性能，以及在此基础上支持事务语义。

目标：

- 描述行存的数据
- 适配存储引擎的结构
- 查找快
- DML快
- 事务语义
- 更少的资源占用（disk、buffer pool、update I/O）

![InnoDB record physical layout design](/InnoDB_record_physical_layout_design.png)





## 逻辑记录的设计

磁盘上的物理记录面向的是计算机友好的，更紧凑、高IO性能。同时，为了性能的考虑，数据也需要常驻内存（buffer pool），所以需要设计数据结构用于表述记录，这被称为tuple（元组），也称为逻辑记录。

# 实现

InnoDB存储引擎中的表使用的是索引组织表（**I**ndex **O**rganized **T**able - **IOT**），这意味着表中的所有数据是按照B+树的方式进行存储的，行数据存在在B+树的叶子节点上，即使创建表时没有显式指定主键索引，也会自动创建一个6字节的隐藏列，用作主键索引。

## 2.1 Redundant行格式

从上面我们可以得知，物理记录由3部分组成：

### 2.1.1 sdfs

sdfs

![ut0lst](/ut0lst.png)