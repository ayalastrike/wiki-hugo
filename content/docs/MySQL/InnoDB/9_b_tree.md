---
typora-root-url: ../../../../static
typora-copy-images-to: ../../../../static
---


在InnoDB中，数据的存储组织为IoT，采用B+ tree的数据结构提供高效访问数据的方式（存取路径）。

# B+ tree

## 概述

B+ tree是由二叉查找树、平衡二叉树、B树演进而来的。

{{< hint info >}}

**二叉查找树 BST（Binary Search Tree）**

**平衡二叉树 AVL（Balanced Binary Tree）**

在计算机科学中，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL 树得名于它的发明者 G. M. Adelson-Velsky 和 Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。

{{</hint>}}

我们在介绍B+ tree之前，先了解一下**binary search tree**。在**BST**中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。因此可以通过**中序遍历**得到键值的排序输出。

中序遍历（LDR - Inorder Traversal）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。

比如有如下二叉查找树：

![InnoDB_b+tree_BST_1](/InnoDB_b+tree_BST_1.png)

中序遍历后输出：2、3、5、6、7、8。

二叉查找树的平均查找速度比顺序查找来得更快：顺序查找的平均查找次数为(1+2+3+4+5+6)/6=3.3次，二叉查找树的平均查找次数为(3+3+3+2+2+1)/6=2.3次。

但是，二叉查找树可以任意地构造，如果构造成下面的二叉查找树：

![InnoDB_b+tree_BST_2](/InnoDB_b+tree_BST_2.png)

则平均查找次数为(1+2+3+4+5+5)/6=3.16次，和顺序查找差不多。因此若想最大性能地构造一个二叉查找树，需要这棵二叉查找树是平衡的，因此引出了平衡二叉树，或称为AVL树。

平衡二叉树的定义如下：首先符合二叉查找树的定义，其次必须满足任何节点的两个儿子子树的高度最大差为1。显然，上图不满足平衡二叉树的定义，而下图是一棵平衡二叉树。平衡二叉树对于查找的性能是比较高的，但不是最高的，只是接近最高性能。最好的性能需要建立一棵最优二叉树，但是最优二叉树的建议和维护需要大量的操作，因此，用户一般只需建立一棵平衡二叉树即可。

平衡二叉树对于查询速度的确很快，但是维护一棵平衡二叉树的代价是需要付出代价的。通常来说，需要1次或多次左旋和右旋来得到插入或更新后树的平衡性。

比如插入9，需要左旋以保证平衡：

![InnoDB_b+tree_AVL_1](/InnoDB_b+tree_AVL_1.png)

有的情况可能需要多次：

![InnoDB_b+tree_AVL_2](/InnoDB_b+tree_AVL_2.png)